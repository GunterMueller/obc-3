(* Parser generated by Mike's special yacc *)

open Yyparse;;

type token =
  | EOF
  | SYMBOL of (string)
  | TAG of (string)
  | NUMBER of (string)
  | SUFFIX of (string)
  | SEMACT of (Lexing.position * string)
  | QUOTE
  | TOKEN
  | LEFT
  | RIGHT
  | NONASSOC
  | START
  | TYPE
  | PREC
  | PPERCENT
  | COLON
  | SEMI
  | VBAR
  | DOT
  | BADTOK
  | UNREACHABLE


# 40 "yacc.mly"

open Print
open Grammar

let prec = ref 0
let index = ref 0
let rhsmap = ref []

let dcl_type tag pos sym =
  if sym.x_type = "" then
    sym.x_type <- tag
  else if sym.x_type <> tag then
    Error.syntax pos 
      "'$' is declared with multiple types" [fSym sym]

let maybe_dcl_type tag pos sym =
  match tag with
      Some t -> dcl_type t pos sym
    | None -> ()

let dcl_token assoc tag pos sym =
  begin match assoc with
      Token ->
        sym.x_genuine <- true;
        if sym.x_kind = Nonterm then sym.x_kind <- Token
    | Left | Right | Nonassoc ->
        if sym.x_kind = Nonterm || sym.x_kind = Token then begin
          sym.x_kind <- assoc; sym.x_prec <- !prec
        end else
          Error.syntax pos
            "'$' is declared with multiple precedences" [fSym sym]
    | _ ->
        failwith "dcl_token"
  end;
  maybe_dcl_type tag pos sym

let dcl_start tag pos sym =
  if List.exists (fun x -> same_syms x sym) !start_syms then
    Error.syntax pos 
      "$ is declared as a start symbol more than once" [fSym sym];
  start_syms := !start_syms @ [sym];
  maybe_dcl_type tag pos sym

let pr_sym = ref None

let gencount = ref 0

let gensym () = 
  incr gencount; lookup (sprintf "yyg$" [fNum !gencount])

let fLeft n fmt =
  let f prf =
    let s0 = sprintf "$" [fmt] in
    let n0 = String.length s0 in
    prf "$" [fStr s0];
    for i = n0+1 to n  do prf "$" [fChr ' '] done in
  fExt f

let dollar_num = Str.regexp "\\$\\([0-9]+\\)"

let subst rhs pos s =
  let i = int_of_string (Str.matched_group 1 s) in
  if i > List.length rhs then
    Error.syntax pos
      "$$ is beyond the end of the rule" [fChr '$'; fNum i]
  else begin
    let x = List.nth rhs (i-1) in
    if not (has_value x) then 
      Error.syntax pos
	"$$ refers to $, which has no value" [fChr '$'; fNum i; fSym x]
  end;
  sprintf "_$" [fNum i]

let dollar_name = 
  Str.regexp "\\$\\([A-Za-z_][A-Za-z0-9_]*\\)"

let subst2 rhs pos s =
  let t = Str.matched_group 1 s in
  match List.filter (fun (x, i) -> x = t) !rhsmap with
      [] -> Error.syntax pos "$$ is not defined" [fChr '$'; fStr t]; ""
    | [(_, i)] -> 
	let x = List.nth rhs (i-1) in
	if not (has_value x) then
	  Error.syntax pos "$$ has no value" [fChr '$'; fStr t];
	sprintf "_$" [fLeft (String.length t) (fNum i)]
    | _ -> Error.syntax pos "$$ is ambiguous" [fChr '$'; fStr t]; ""

let make_action rhs (pos, text) =
  let text' = Str.global_substitute dollar_num (subst rhs pos) text in
  let text'' = Str.global_substitute dollar_name (subst2 rhs pos) text' in
  (pos, text'')

# 123 "yacc.ml"
let yyconst = [|
  0; (* EOF *)
  7; (* QUOTE *)
  8; (* TOKEN *)
  9; (* LEFT *)
  10; (* RIGHT *)
  11; (* NONASSOC *)
  12; (* START *)
  13; (* TYPE *)
  14; (* PREC *)
  15; (* PPERCENT *)
  16; (* COLON *)
  17; (* SEMI *)
  18; (* VBAR *)
  19; (* DOT *)
  20; (* BADTOK *)
  21; (* UNREACHABLE *)
|]

let yyblock = [|
  2; (* SYMBOL *)
  3; (* TAG *)
  4; (* NUMBER *)
  5; (* SUFFIX *)
  6; (* SEMACT *)
|]

let yylhs = [|
    -1;     1;     2;     2;     2;     2;     2;     4;     4;     4;
     4;     5;     5;     6;     6;     3;     3;     8;     9;     9;
    10;    11;    12;    12;    12;    12;    13;    13;     7;     0;
|]

let yyrlen = [|
     2;     3;     0;     4;     4;     4;     2;     1;     1;     1;
     1;     0;     1;     0;     2;     0;     2;     4;     1;     3;
     3;     0;     0;     2;     3;     2;     1;     2;     1;     2;
|]

let yyaction = [|
    45;     0;     0;     0;    41;     0;     0;     0;     0;     0;
    20;    35;     0;    20;     0;    32;    32;     2;    32;     0;
     0;    32;     0;    21;     0;     0;     0;     0;    19;    -6;
     0;     0;     0;    12;     0;     3;    23;     1;     0;     0;
     0;
|]

let yydefact = [|
     0;     0;    -2;   -29;     0;    -6;    -7;    -8;    -9;   -10;
     0;     0;   -15;     0;   -12;     0;     0;     0;     0;   -28;
    -4;     0;    -5;     0;   -16;    -3;   -14;   -21;     0;     0;
   -22;   -17;   -21;     0;   -19;     0;     0;     0;   -23;   -24;
   -27;
|]

let yygoto = [|
     0;     0;     0;     0;     0;    11;    -8;   -17;     0;   -31;
     0;     0;     0;     0;
|]

let yydefgoto = [|
     1;     3;     4;    17;    13;    15;    20;    21;    24;    28;
    29;    30;    33;    38;
|]

let yytabsize = 57

let yytable = [|
    23;    34;    -1;   -26;    19;   -25;    40;   -26;    22;   -25;
    25;   -18;    32;    26;    19;   -26;    37;   -25;    35;    39;
   -20;   -20;   -11;    14;    18;    19;    36;   -11;   -11;   -11;
   -11;   -11;   -11;   -11;    19;   -11;    31;    27;    16;   -13;
   -13;   -13;   -13;   -13;   -13;   -13;     2;   -13;     5;     6;
     7;     8;     9;    10;    11;     0;    12;
|]

let yycheck = [|
    17;    32;     0;     2;     2;     2;     5;     6;    16;     6;
    18;    17;    18;    21;     2;    14;    33;    14;     6;    36;
    17;    18;     2;     3;    13;     2;    14;     7;     8;     9;
    10;    11;    12;    13;     2;    15;    17;    16;     3;     7;
     8;     9;    10;    11;    12;    13;     1;    15;     7;     8;
     9;    10;    11;    12;    13; -1000;    15;
|]

let yyname = [|
"EOF"; "*1*"; "SYMBOL"; "TAG"; "NUMBER"; "SUFFIX"; "SEMACT"; 
"QUOTE"; "TOKEN"; "LEFT"; "RIGHT"; "NONASSOC"; "START"; "TYPE"; 
"PREC"; "PPERCENT"; "COLON"; "SEMI"; "VBAR"; "DOT"; "BADTOK"; 
"UNREACHABLE"; 
|]

let yyrule = [|
"*start* --> *entry* EOF";
"grammar --> heading PPERCENT body";
"heading --> []";
"heading --> heading assoc tag symbols";
"heading --> heading START tag symbols";
"heading --> heading TYPE TAG symbols";
"heading --> heading QUOTE";
"assoc --> TOKEN";
"assoc --> LEFT";
"assoc --> RIGHT";
"assoc --> NONASSOC";
"tag --> []";
"tag --> TAG";
"symbols --> []";
"symbols --> symbol symbols";
"body --> []";
"body --> body para";
"para --> symbol COLON prods SEMI";
"prods --> prod";
"prods --> prod VBAR prods";
"prod --> init rhs SEMACT";
"init --> []";
"rhs --> []";
"rhs --> rhs item";
"rhs --> rhs PREC symbol";
"rhs --> rhs SEMACT";
"item --> symbol";
"item --> symbol SUFFIX";
"symbol --> SYMBOL";
"*entry* --> *1* grammar";
|]

let yysemact = [|
(fun () -> failwith "parser");
(fun () ->
  let _1 = (yypeek 1 : 't_heading) in
  let _3 = (yypeek 3 : 't_body) in
  Obj.repr (
# 136 "yacc.mly"
                                ( () )
# 257 "yacc.ml"
		: unit));
(fun () ->
  Obj.repr (
# 139 "yacc.mly"
                                ( () )
# 263 "yacc.ml"
		: 't_heading));
(fun () ->
  let _1 = (yypeek 1 : 't_heading) in
  let _2 = (yypeek 2 : 't_assoc) in
  let _3 = (yypeek 3 : 't_tag) in
  let _4 = (yypeek 4 : 't_symbols) in
  Obj.repr (
# 141 "yacc.mly"
      ( List.iter (dcl_token _2     _3   (rhs_start_pos 2)) _4       )
# 273 "yacc.ml"
		: 't_heading));
(fun () ->
  let _1 = (yypeek 1 : 't_heading) in
  let _3 = (yypeek 3 : 't_tag) in
  let _4 = (yypeek 4 : 't_symbols) in
  Obj.repr (
# 143 "yacc.mly"
      ( List.iter (dcl_start _3   (rhs_start_pos 2)) _4       )
# 282 "yacc.ml"
		: 't_heading));
(fun () ->
  let _1 = (yypeek 1 : 't_heading) in
  let _3 = (yypeek 3 : string) in
  let _4 = (yypeek 4 : 't_symbols) in
  Obj.repr (
# 145 "yacc.mly"
      ( List.iter (dcl_type _3   (rhs_start_pos 2)) _4       )
# 291 "yacc.ml"
		: 't_heading));
(fun () ->
  let _1 = (yypeek 1 : 't_heading) in
  Obj.repr (
# 146 "yacc.mly"
                                ( () )
# 298 "yacc.ml"
		: 't_heading));
(fun () ->
  Obj.repr (
# 149 "yacc.mly"
                                ( Token )
# 304 "yacc.ml"
		: 't_assoc));
(fun () ->
  Obj.repr (
# 150 "yacc.mly"
                                ( incr prec; Left )
# 310 "yacc.ml"
		: 't_assoc));
(fun () ->
  Obj.repr (
# 151 "yacc.mly"
                                ( incr prec; Right )
# 316 "yacc.ml"
		: 't_assoc));
(fun () ->
  Obj.repr (
# 152 "yacc.mly"
                                ( incr prec; Nonassoc )
# 322 "yacc.ml"
		: 't_assoc));
(fun () ->
  Obj.repr (
# 155 "yacc.mly"
                                ( None )
# 328 "yacc.ml"
		: 't_tag));
(fun () ->
  let _1 = (yypeek 1 : string) in
  Obj.repr (
# 156 "yacc.mly"
                                ( Some _1   )
# 335 "yacc.ml"
		: 't_tag));
(fun () ->
  Obj.repr (
# 159 "yacc.mly"
                                ( [] )
# 341 "yacc.ml"
		: 't_symbols));
(fun () ->
  let _1 = (yypeek 1 : 't_symbol) in
  let _2 = (yypeek 2 : 't_symbols) in
  Obj.repr (
# 160 "yacc.mly"
                                ( _1     ::_2       )
# 349 "yacc.ml"
		: 't_symbols));
(fun () ->
  Obj.repr (
# 163 "yacc.mly"
                                ( () )
# 355 "yacc.ml"
		: 't_body));
(fun () ->
  let _1 = (yypeek 1 : 't_body) in
  let _2 = (yypeek 2 : 't_para) in
  Obj.repr (
# 164 "yacc.mly"
                                ( () )
# 363 "yacc.ml"
		: 't_body));
(fun () ->
  let _1 = (yypeek 1 : 't_symbol) in
  let _3 = (yypeek 3 : 't_prods) in
  Obj.repr (
# 168 "yacc.mly"
      ( if not (is_nonterm _1     ) then
	  Error.syntax (rhs_start_pos 1) "left-hand side is a token" [];
	if !Grammar.start_syms = [] then
	  Grammar.start_syms := [_1     ];
	List.iter (fun (line, rhs, prec, semact) ->
	  ignore (create_rule _1      rhs prec semact line)) _3     )
# 376 "yacc.ml"
		: 't_para));
(fun () ->
  let _1 = (yypeek 1 : 't_prod) in
  Obj.repr (
# 176 "yacc.mly"
                                ( [_1   ] )
# 383 "yacc.ml"
		: 't_prods));
(fun () ->
  let _1 = (yypeek 1 : 't_prod) in
  let _3 = (yypeek 3 : 't_prods) in
  Obj.repr (
# 177 "yacc.mly"
                                ( _1   ::_3     )
# 391 "yacc.ml"
		: 't_prods));
(fun () ->
  let _1 = (yypeek 1 : 't_init) in
  let _2 = (yypeek 2 : 't_rhs) in
  let _3 = (yypeek 3 : Lexing.position * string) in
  Obj.repr (
# 181 "yacc.mly"
      ( let a = make_action _2   _3      in
	(rhs_start_pos 2, _2  , !pr_sym, a) )
# 401 "yacc.ml"
		: 't_prod));
(fun () ->
  Obj.repr (
# 185 "yacc.mly"
                                ( pr_sym := None )
# 407 "yacc.ml"
		: 't_init));
(fun () ->
  Obj.repr (
# 189 "yacc.mly"
      ( index := 0; rhsmap := []; [] )
# 413 "yacc.ml"
		: 't_rhs));
(fun () ->
  let _1 = (yypeek 1 : 't_rhs) in
  let _2 = (yypeek 2 : 't_item) in
  Obj.repr (
# 191 "yacc.mly"
      ( let (x, y) = _2    in
	if is_token x then pr_sym := Some x;
        if not (is_token x) || not (same_syms x error_sym) then
          x.x_genuine <- true;
	incr index; rhsmap := !rhsmap @ [(y, !index)];
        _1   @ [x] )
# 426 "yacc.ml"
		: 't_rhs));
(fun () ->
  let _1 = (yypeek 1 : 't_rhs) in
  let _3 = (yypeek 3 : 't_symbol) in
  Obj.repr (
# 198 "yacc.mly"
      ( let x = _3      in
        if not (is_token x) then 
          Error.syntax (rhs_start_pos 2)
            "%prec must be followed by a token" [];
        if x.x_kind = Token then 
          Error.syntax (rhs_start_pos 2)
            "%prec must be followed by a token with defined precedence" [];
        pr_sym := Some x;
        _1   )
# 442 "yacc.ml"
		: 't_rhs));
(fun () ->
  let _1 = (yypeek 1 : 't_rhs) in
  let _2 = (yypeek 2 : Lexing.position * string) in
  Obj.repr (
# 208 "yacc.mly"
      ( let g = gensym () in
	let a = make_action _1   _2      in
        let r = create_rule g [] None a (fst a) in
	incr index;
	r.r_context <- _1  ; 
	_1   @ [g] )
# 455 "yacc.ml"
		: 't_rhs));
(fun () ->
  let _1 = (yypeek 1 : 't_symbol) in
  Obj.repr (
# 216 "yacc.mly"
             ( (_1     , _1     .x_name) )
# 462 "yacc.ml"
		: 't_item));
(fun () ->
  let _1 = (yypeek 1 : 't_symbol) in
  let _2 = (yypeek 2 : string) in
  Obj.repr (
# 217 "yacc.mly"
                   ( (_1     , _1     .x_name^_2     ) )
# 470 "yacc.ml"
		: 't_item));
(fun () ->
  let _1 = (yypeek 1 : string) in
  Obj.repr (
# 220 "yacc.mly"
             ( Grammar.lookup _1      )
# 477 "yacc.ml"
		: 't_symbol));
(* Entry grammar *)
(fun () -> raise (YYexit (yypeek 2)));
|]

let yytables =
  { yysemact = yysemact;
    yyconst = yyconst;
    yyblock = yyblock;
    yylhs = yylhs;
    yyrlen = yyrlen;
    yyaction = yyaction;
	   yydefact = yydefact;
    yygoto = yygoto;
    yydefgoto = yydefgoto;
    yytabsize = yytabsize;
    yytable = yytable;
    yycheck = yycheck;
    yyerror = parse_error;
    yyname = yyname;
    yyrule = yyrule }

let grammar (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
  (yyparse yytables 1 lexfun lexbuf : unit)


