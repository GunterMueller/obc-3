MODULE tSpigot;

IMPORT MathL, Out;

(* Terms -- count terms needed for N digits *)
PROCEDURE Terms(n: INTEGER): INTEGER;
  VAR m: INTEGER; y: LONGREAL;
BEGIN
  (* Find m s.t. m! > 10^(n+1)
     <=> sqrt(2 pi m) m^m e^(-m) > 10^(n+1)
     <=> ln (2 pi m)/2 + m ln m - m > (n+1) ln 10 *)
  m := 4; y := (n+1)*MathL.Ln(10);
  WHILE MathL.Ln(2*MathL.pi*m)/2 + m*(MathL.Ln(m)-1) <= y DO
    m := m+1
  END;
  RETURN m
END Terms;

VAR d: ARRAY 1000 OF INTEGER;

(* After Digits(n), d = [7, 1, 8, ...] *)

(* Digits -- compute digits of e *)
PROCEDURE Digits(n: INTEGER);
  VAR i, j, t, carry, temp: INTEGER;
    coef: ARRAY 1000 OF INTEGER;
BEGIN
  t := Terms(n);
  Out.Int(t, 0); Out.String(" terms"); Out.Ln;
  FOR j := 1 TO t-1 DO coef[j] := 1 END;

  FOR i := 0 TO n-1 DO
    carry := 0;
    FOR j := t-1 TO 1 BY -1 DO
      temp := coef[j]*10 + carry;
      carry := temp DIV (j+1);
      coef[j] := temp - carry*(j+1)
    END;
    d[i] := carry
  END
END Digits;

VAR i, j: INTEGER;

BEGIN
  Digits(1000);
  FOR i := 0 TO 19 DO
    IF i = 0 THEN Out.String("2.") ELSE Out.String("  ") END;
    FOR j := 0 TO 49 DO Out.Int(d[50*i+j], 0) END;
    Out.Ln
  END
END tSpigot.

(*<<
451 terms
2.71828182845904523536028747135266249775724709369995
  95749669676277240766303535475945713821785251664274
  27466391932003059921817413596629043572900334295260
  59563073813232862794349076323382988075319525101901
  15738341879307021540891499348841675092447614606680
  82264800168477411853742345442437107539077744992069
  55170276183860626133138458300075204493382656029760
  67371132007093287091274437470472306969772093101416
  92836819025515108657463772111252389784425056953696
  77078544996996794686445490598793163688923009879312
  77361782154249992295763514822082698951936680331825
  28869398496465105820939239829488793320362509443117
  30123819706841614039701983767932068328237646480429
  53118023287825098194558153017567173613320698112509
  96181881593041690351598888519345807273866738589422
  87922849989208680582574927961048419844436346324496
  84875602336248270419786232090021609902353043699418
  49146314093431738143640546253152096183690888707016
  76839642437814059271456354906130310720851038375051
  01157477041718986106873969655212671546889570350354
>>*)

(*[[
!! (SYMFILE #tSpigot STAMP #tSpigot.%main 1 #tSpigot.m)
!! (CHKSUM STAMP)
!! 
MODULE tSpigot STAMP 0
IMPORT MathL STAMP
IMPORT Out STAMP
ENDHDR

PROC tSpigot.Terms 12 8 0
! PROCEDURE Terms(n: INTEGER): INTEGER;
!   m := 4; y := (n+1)*MathL.Ln(10);
CONST 4
STLW -4
LDLW 12
INC
CONVND
DCONST 10.0
GLOBAL MathL.Ln
CALLD 2
DTIMES
STLD -12
LABEL L4
!   WHILE MathL.Ln(2*MathL.pi*m)/2 + m*(MathL.Ln(m)-1) <= y DO
LDLW -4
CONVND
DCONST 6.28318530718
DTIMES
GLOBAL MathL.Ln
CALLD 2
DCONST 2.0
DDIV
LDLW -4
CONVND
LDLW -4
CONVND
GLOBAL MathL.Ln
CALLD 2
DCONST 1.0
DMINUS
DTIMES
DPLUS
LDLD -12
DJNLEQ L6
!     m := m+1
INCL -4
JUMP L4
LABEL L6
!   RETURN m
LDLW -4
RETURN
END

PROC tSpigot.Digits 4028 4 0
! PROCEDURE Digits(n: INTEGER);
!   t := Terms(n);
LDLW 12
GLOBAL tSpigot.Terms
CALLW 1
STLW -12
!   Out.Int(t, 0); Out.String(" terms"); Out.Ln;
CONST 0
LDLW -12
GLOBAL Out.Int
CALL 2
CONST 7
GLOBAL tSpigot.%1
GLOBAL Out.String
CALL 2
GLOBAL Out.Ln
CALL 0
!   FOR j := 1 TO t-1 DO coef[j] := 1 END;
LDLW -12
DEC
STLW -4024
CONST 1
STLW -8
LABEL L7
LDLW -8
LDLW -4024
JGT L8
CONST 1
LOCAL -4020
LDLW -8
CONST 1000
BOUND 30
STIW
INCL -8
JUMP L7
LABEL L8
!   FOR i := 0 TO n-1 DO
LDLW 12
DEC
STLW -4028
CONST 0
STLW -4
LABEL L9
LDLW -4
LDLW -4028
JGT L10
!     carry := 0;
CONST 0
STLW -16
!     FOR j := t-1 TO 1 BY -1 DO
LDLW -12
DEC
STLW -8
LABEL L11
LDLW -8
CONST 1
JLT L12
!       temp := coef[j]*10 + carry;
LOCAL -4020
LDLW -8
CONST 1000
BOUND 35
LDIW
CONST 10
TIMES
LDLW -16
PLUS
STLW -20
!       carry := temp DIV (j+1);
LDLW -20
LDLW -8
INC
ZCHECK 36
DIV
STLW -16
!       coef[j] := temp - carry*(j+1)
LDLW -20
LDLW -16
LDLW -8
INC
TIMES
MINUS
LOCAL -4020
LDLW -8
CONST 1000
BOUND 37
STIW
!     FOR j := t-1 TO 1 BY -1 DO
DECL -8
JUMP L11
LABEL L12
!     d[i] := carry
LDLW -16
GLOBAL tSpigot.d
LDLW -4
CONST 1000
BOUND 39
STIW
!   FOR i := 0 TO n-1 DO
INCL -4
JUMP L9
LABEL L10
RETURN
END

PROC tSpigot.%main 0 4 0
!   Digits(1000);
CONST 1000
GLOBAL tSpigot.Digits
CALL 1
!   FOR i := 0 TO 19 DO
CONST 0
STGW tSpigot.i
LABEL L13
LDGW tSpigot.i
CONST 19
JGT L14
!     IF i = 0 THEN Out.String("2.") ELSE Out.String("  ") END;
LDGW tSpigot.i
JNEQZ L17
CONST 3
GLOBAL tSpigot.%2
GLOBAL Out.String
CALL 2
JUMP L15
LABEL L17
CONST 3
GLOBAL tSpigot.%3
GLOBAL Out.String
CALL 2
LABEL L15
!     FOR j := 0 TO 49 DO Out.Int(d[50*i+j], 0) END;
CONST 0
STGW tSpigot.j
LABEL L18
LDGW tSpigot.j
CONST 49
JGT L19
CONST 0
GLOBAL tSpigot.d
LDGW tSpigot.i
CONST 50
TIMES
LDGW tSpigot.j
PLUS
CONST 1000
BOUND 49
LDIW
GLOBAL Out.Int
CALL 2
LDGW tSpigot.j
INC
STGW tSpigot.j
JUMP L18
LABEL L19
!     Out.Ln
GLOBAL Out.Ln
CALL 0
!   FOR i := 0 TO 19 DO
LDGW tSpigot.i
INC
STGW tSpigot.i
JUMP L13
LABEL L14
RETURN
END

! Global variables
GLOVAR tSpigot.d 4000
GLOVAR tSpigot.i 4
GLOVAR tSpigot.j 4

! String " terms"
DEFINE tSpigot.%1
STRING 207465726D7300

! String "2."
DEFINE tSpigot.%2
STRING 322E00

! String "  "
DEFINE tSpigot.%3
STRING 202000

! End of file
]]*)
